





　　　　　　　　　１３６０用クロスコンパイラ 

　　　　　　　　　　　ＴＮＫＢ Ver 1.01

    　　　　　　        Alpha version.





　　　　　　　　　　　    【著作権について】

　　・このプログラムの著作権は作者である綿貫克が保持します。
    ・このプログラムの使用して起こるいかなる損害も作者は責任を負いません。
　　・個人使用の範囲内であれば改変は自由です。



　０．初めに

　　　1360のゲーム作成ツールといえばすぐに「ＴＹコンパイラ」が思い浮かびます。
　　その「ＴＹコンパイラ」も、使っているうちに以下の改善要望を持ちました。

　　　a)  文法エラー時には、メッセージを出力してコンパイルを中止して欲しい。
　　　b)  変数の扱いや文法をＢＡＳＩＣに近いものにして欲しい。


　　　では、「ＴＹコンパイラ」を改造すべきでしょうか？
　　しかし、それに手を加えるのは容易な事ではありませんでした。

　　　そこで、私はコンパイラを独自に開発しました。本プログラムは再帰降下型の
　　構文解析という技術を基に作成されました。私はこの技術の習得におおよそ４年
　　かかりました。それだけに喜びもひとしおです。


　１．使用方法


　　１．１　準備

　　　TnkBを使用するためには以下の準備が必要です。

　　　1)　パソコンと１３６０およびこれを接続する通信アダプタとクロスケーブル
      2)  ＴＹコンパイラのランタイムルーチン   RUNTIME.OBJ
      3)　１３６０用マシン語ファイル転送ソフト BINRS.EXE および BINRX.OBJ
      4)  １３６０用クロスアセンブラ 　　　　　TNKASM.EXE
      5)　１３６０用クロスコンパイラ　　　　　 TNKB.EXE および RUNTIME.H


        １３６０とパソコンを通信アダプタを介してクロスケーブルで接続します。
　　　通信アダプタは純正品のＣＥ−１３０Ｔがありますが ORANGE氏の考案された
　　　「レベルダウンコンバータ」を用いることができます。

　　　　ＢＩＮＲＳをダウンロードし、ＤＯＣファイルの説明に従って１３６０に
　　　ＢＩＮＲＸをロードして下さい。もちろんパソコン側にもＢＩＮＲＳを準備
　　　しておきます。

　　　　ＴＹコンパイラの”ＲＵＮＴＩＭＥ．ＯＢＪ”を１３６０にロードして下
　　　さい。”ＲＵＮＴＩＭＥ．ＯＢＪ”がない場合コンパイラで作成したマシン
　　　語プログラムは動作できません。（暴走します。）

  　　　ＴＹコンパイラは工学社「ＰＩＯスペシャル３」にて発表されました。
  　　１３６０友達から手にいれましょう。どうしても入手できない時は相談にの
  　　ります。



　　１．２　TnkBの開発フロー

　　     TnkBを用いたプログラム開発は以下の
　　　 ように行われます。


     (Start)
        !
     (Editor) <----+  エディット : Word Masterなどを用いてTnkCのソースを作成
        !          !
        !     Error!
     ( TnkB )------+  コンパイル : TnkBを用いてアセンブラファイルに変換
        !
        !
     (TnkAsm)         アセンブル : TnkAsmを用いてバイナリファイルに変換
        !                          (*1)
        !
     ( BINRS )        ロード     : BINRSにより１３６０に転送
        !　　　　　　　　　　　　　(*2)
        !
     ( End )

　　  *1
　　　　　TnkAsmは１３６０用クロスアセンブラです。詳細についてはTnkAsmを参照し
　　　　てください。（;BBSPREにアップロードしてあります。）

  　  *2
　　　　　BINRSはＲｅｖ氏作成の１３６０用通信ソフトです。詳細についてはBINRSを
　　　　参照してください。（;BBSSHARPにアップロードされております。）


　　１．３　コンパイルの方法

　　　　　コマンドラインに以下のように入力します。
　　　　拡張子を省略すると ﾌｧｲﾙ名 .TNK が仮定されます。

  　　　　TNKB   ﾌｧｲﾙ名 [ .拡張子 ]


　　　　　ＴＮＫＢは、ﾌｧｲﾙ名で示されるソースをコンパイルし、ﾌｧｲﾙ名.ASCとい
　　　　うファイルを作成します。生成されたファイルはそのままでは１３６０で
　　　　は使用出来ません。


　　１．４　バイナリファイルの作成。

　　　　　１３６０で使用するためには別にＴＮＫＡＳＭを用いてバイナリファイルを
　　　　作成する作業が必要です。コマンドラインに以下のように入力してください。

          TNKASM ﾌｧｲﾙ名

　　　　　これにより、ﾌｧｲﾙ名.OSC というバイナリファイルが作成されました。
　　　　１３６０に転送するにはBINRSを使用します。転送の方法はBINRSのDOCファイ
　　　　ルをご参照下さい。



　２．文法

　　　　TnkBのソースは以下のような形をしています。

     【 TnKBのソース（例） 】
     
      10 FOR A=0 TO 10
      20   PRINT A
      30 NEXT A
      40 END


　　　　文には一行毎に行番号があり、一行は複数のステートメントから構成さ
　　　れています。

　　【 制限 】

　　　　TnkBソース中に全角文字やﾀﾌﾞ記号を入れてはいけません。
　　　字句解析手続きが無限ループします。


　　２．１　扱えるデータ

　　　　　データは１バイトの大きさを持ち、以下の種類があります。

　　　　　
　　　　　正の整数

　　　　　・１０進数　　１バイトの符号なし整数です。

　　　　　　　例  10

　　　　　・１６進数　　＆で始まる１バイトの符号なし整数です。

　　　　　　　例　&1A


　　　　　文字　　　　”で囲まれた１バイトの文字コードです。

　　　　　　　例  "X"


　　２．２　変数

　　　　　変数はデータを格納しておく入れ物で、以下の種類があります。

　　　・単純変数

　　　　　　単純変数は英文字から始まる英数字８文字までの名前を持ちます。
　　　　　変数には正の整数と文字変数があり、＄記号により区別をします。

　　　　　正の整数：０〜２５５までの範囲の数を記憶している変数です。

　　　　　文字変数：１バイトの文字を記憶している変数です。

　　　　　例  TANUKI　　　正の整数用の単純変数
              MAN　　　　 同じく
              COMPILER　　同じく
              C3PO$ 　　　文字用の単純変数
         　　 R2D2$　　　 同じく

　　　　　　単純変数はプログラムに登場する順に内部ＲＡＭに一つずつ割り
　　　　　当てられます。

　　　・配列変数

　　　　　　配列宣言により、配列変数を使用することが出来ます。
　　　　　単純変数と同じく１バイトの数値を記憶するためのものですが、配列
　　　　　変数の場合には変数を表のように扱うことができます。

　　　　　　配列変数も英文字から始まる英数字８文字までの名前を持ちます。

　　　　　　配列変数は宣言順に連続して内部ＲＡＭに割り当てられますが、
　　　　　単純変数と配列変数を合計２７個以上内部ＲＡＭに割り当てようとす
　　　　　るとコンパイルエラーとなります。


　　２．３　式

　　　　　演算は正の整数どうしに限られ、変数および定数の加減乗除、ＡＮＤ
　　　　ＯＲ、それに関係演算ができます。

　　　　【とても残念ですが文字列の加算は出来ません。】

　　　　　例  A$ = "ABCD" + "EFGH"  …これはＮＧです。


　　　・正の整数どうしの加減乗除：桁溢れは無くなります。
				　例えば５＋２５１の値は０になります。
　　　　　　　　　　　　　　　　　演算記号はＢＡＳＩＣと同じです。

　　　　　例　TERM = FACTOR + FACTOR

　　　・ＡＮＤとＯＲ　　　　　　：ＢＡＳＩＣと同じです。

　　　　　例　LOWCASE = UPCASE AND 16


　　　・関係演算　　　　　　　　：条件成立時２５５、不成立時に０になります。
　　　　　　　　　　　　　　　　　演算記号は＝，＞＝，＜＝，＜＞です。

　　　　　例  CARRY = (A >= B)


　　　・演算の優先順位

　　　　　順位１．ＡＮＤ及び×
　　　　　順位２．ＯＲ及び＋
　　　　　順位３．関係演算


　　２．４　関数

　　　　　ＴＹコンパイラと同じ関数をサポートしています。


　　　　ASC関数     　文字のアスキーコードを得る。

　　　　　　例     A = ASC(B$)


　　　　CHR$関数    　式の値をアスキーコードとする文字を得る。

　　　　　　例　　 B$ = CHR$(A+3)


　　　　INKEY$関数  　キー入力された文字を得る。

　　　　　　例　　 K$ = INKEY$


　　　　POINT関数   　グラフィックパターンを得る。

　　　　　　例　　 PATTERN = POINT(BEAMX , BEAMY) 


　　　　RND関数     　０から式の値までの範囲で乱数を得る。

　　　　　　例　　 XPOS = RND(4)　　０から４までの乱数を得る。


　　　　ﾙｰﾄ関数     　平方根を得る。（但し、結果は正の整数）

　　　　　　例　　ROOT = SQRT(4)


　　２．５　ステートメント

　　　　ＴＹコンパイラに加えて、新しくＦＯＲ文とＮＥＸＴ文、およびＤＩＭ
　　　文とＲＥＭ文をサポートしました。

　　　　さらに、ＩＦ文はＬＥＴやＴＨＥＮの後にマルチステートメントを書く
　　　ことができ、ＢＡＳＩＣに近い感覚でプログラムすることができます。


　　　以下ＡＢＣ順に説明します。


　　　　BEEP文  音楽を鳴らします。

　　　　　BEEP ON　　　　　　演奏の許可

          BEEP OFF　　	　　 演奏の禁止

          BEEP "CDEFGAB"     ドレミファソラシド


　　　　CLEAR文　内部ＲＡＭを全てクリアします。

          CLEAR


　　　　CLS文　　画面表示を消します。

          CLS　               全画面を消します
          CLS n  (n=0..3)     n で示す行を消します。


　　　　CURSOR文　文字を表示する位置を決定します

          CURSOR 3,3


　　　　DATA文　データテーブルを作成します。

          DATA 10,11,13,14


　　　　END文　プログラムを終了します

          END


　　　　GCURSOR文 　グラフィックのカーソル位置を決定します

          GCURSOR(10,10)


　　　　GOSUB文   サブルーチンを呼び出します。

           GOSUB 210


　　　　GOTO文　プログラムの流れを無条件に変更します。

           GOTO 10


　　　　GPRINT文　グラフィックパターンを表示します。

           GPRINT "0123456789ABCDEF"


　　　　IF文　プログラムの流れを式の値に応じて変更します。

           IF A>10 LET A = 10
           IF (A=10) AND (B = 20) THEN PRINT A+B:GOTO 320


　　　　INPUT文　キー入力を行い、結果を文字変数に格納します。

           INPUT A$


　　　　PRESET文　グラフィックカーソル位置の１ドットを消去します。

           PRESET(STARX,STARY)


　　　　PRINT文　文字カーソル位置に文字を表示します。

           PRINT "Hello, SC!"


　　　　PSET文   グラフィックカーソル位置の１ドットを表示します。

           PSET(STARX,STARY)


　　　　READ文   データをDATA文で確保したテーブルから読みだします。
                 RESTORE文をあらかじめ実行する必要があります。

           READ X,Y


　　　　RESTORE文　データテーブルの読みだし準備を行います。

           RESTORE 340


　　　　RETURN文 サブルーチンからメインルーチンに復帰します。

           RETURN


　　　　USING文  数値の表示方法を決定します。

          USING  2      数値を２桁で表示
          USING  3      数値を３桁で表示
          USING         USING指定の解除

　　　　WAIT文   プログラムのスピードをコントロールします。

          WAIT n (n=0-255)　nが多い程スピードが低下します。
          WAIT              プログラムを停止します。

　　　　ｲﾝﾗｲﾝ文   TnkBの出力ファイル中にマシン語プログラムを
　　　　　　　　　展開します。



　３．プログラム内容

　　　TnkBは主に３つの手続きに分かれています。

　　　　字句解析手続き
　　　　式のコンパイル手続き
　　　　文のコンパイル手続き



　　３．１　字句解析手続き

　　　Getchar手続き
　　　　　ソースリストから文字を１つピックアップし、変数chに格納する。
　　　　但しソースリストはフリーフォーマット形式。


　　　Getsymbol手続き
　　　　　Getcharにより得た変数chが何かを調べる。
　　　　そのchによって以下の処理を行う。


　　　＜ 空白:Space ＞
        Ch が空白の時は読みとばす。


　　　＜ １０進定数:Decimal ＞
        　Ch が数字の時＜１０進定数＞とみなし、数字の続く限りGetchar
        手続きを呼出し、chを読み続ける。
　　　　＜１０進定数＞を変数 inum に格納する。
       変数 Symbol には intliteral を返す。


　　　＜ 文字定数:Letters ＞
        Ch が記号”の時＜文字定数＞とみなし、次に記号”の来る限り読
　　　　み続け、文字列を変数Stringsに格納する。変数 Symbol はLetters
        を格納する。


　　　＜ 識別子:Identefier ＞
        Ch が英数字の時に続く文字は＜識別子＞である
        
        ＜ステートメント＞の識別子であれば、その種類を字句の型へ返す。
        その他のときは＜関数＞かもしれないので、文字列を変数 ID に格納
　　　　する。変数 Symbol にはIdentifierを格納する。

　　　　英字Ａまたは英字Ｂの時＜変数名＞とみなす。続く文字が記号＄の
        時は特に、＜文字定数＞であるとみなす。変数 SymbolはIdentifier。

　　　　　さらに続く文字が記号（であれば、それは＜配列変数＞であるが
　　　　字句解析では配列の添字まで言及しない。＜因子＞の解析において
　　　　＜配列の添字＞::= （＜式＞）という構文を解析する。


　　　＜ インライン展開 Inline statement ＞
        Ch が　！記号の時に続く文字はインライン展開用の文字である。
        その文字が０−９，Ａ−Ｆである限りGetChar手続きにより読み取り
        変数 Strings に格納。変数 Symbol は SyInline


　　　＜ 特殊記号  Others ＞
        Ch が比較演算子などの特殊記号の時にはその種類を返す。


　　３．２　式のコンパイル手続き

　　　　３．２．１　概要

　　　　　　式のコンパイルは式の構文をプログラム化することにより実現出来
　　　　　ます。

            式の優先順位は以下のとおりです。
            
            （式）または関数 ＞ 関係演算 ＞ 乗法演算 ＞ 加法演算

            2*3+4 は、まず乗法演算である 2*3を行い、続いて+4という加法演
            算を行います。


　　　　３．２．２　手続きの仕様
　　　　　　
　　　　　　＜式＞を以下のように定義します。

　　　　　　　　<式>       ::= <単純式> <関係演算子> <単純式>

　　　　　　　　<単純式>   ::= <項> { <加法演算子> <項> }

　　　　　　　　<項>       ::= <因子> { <乗法演算子> <因子> }

　　　　　　　　<因子>     ::= <定数> | <変数> | <関数> |（式）


　　　　　　Expression手続き
　　　　　　　式の入口です。関係演算の続く限りここで処理を続けます。

            Simpleexpression手続き
            　単純式の入口です。乗法演算の続く限り以下の処理を続けます。

　　　　　　　因子の型チェック
　　　　　　　因子同士を乗するオブジェクトを生成する。
            
            Term手続き
            　項の入口です。加法演算の続く限り以下の処理を続けます。

　　　　　　　因子の型チェック
　　　　　　　因子同士を加算するオブジェクトを生成する。

            Factor手続き
　　　　　　　因子の種類に応じて以下の処理を行います。
              定数   : Literal   　定数の値を求める。
              識別子 : Identifier　変数のアドレスを求める
              左括弧 : LeftParen　 Expression手続きを呼び出す。



　　３．３　文のコンパイル手続き

　　　　３．３．１　概要

　　　　　　文をコンパイルするということもまた、ＢＮＦによって定義された
　　　　　構文図をプログラム化することにより実現出来るのです。


　　　　３．３．２　手続きの仕様


          ＜文＞、＜行＞、＜ﾌﾟﾛｸﾞﾗﾑ＞を以下のとおり定義します。

          <文>            ::= <代入文>|<実効文>
          <行>            ::= <行番号><文>{：<文>}<改行>
          <TNKCのﾌﾟﾛｸﾞﾗﾑ> ::= <行>{<行>}<EOF>


           Assignstatement手続き
            　代入文をコンパイルします。

              <代入文> ::= <変数名>＝＜式＞

            　 先ず字句解析ルーチンからIdentifierが戻ってきたらそれは
             <変数名>です。変数リストをチェックします。

             　次にSyeqが戻って来るはずです。Syeqが戻ってきたら、<式>
             のコンパイル手続きを呼び出します。

            　 式のコンパイル手続きは、結果をＡレジスタに格納するオブ
             ジェクトを生成するので＜代入文＞としてはＡレジスタの内容
             を変数にストアするオブジェクトを付加してあげればＯＫです。


           ExecuteStatement手続き
            　＜代入文＞以外の文である＜実効文＞をコンパイルします。
            
            　  ＜実効文＞には非常にたくさんのバリエーションがあります。
　　　　　　　そのため、文一つ毎に手続きが用意されています。


           Statement手続き
            　　文をコンパイルします。

　　　　　　 　 文の種類を判別し、Assignstatement手続きまたはExecute-
  　          Statement手続きを呼び出します。


           Oneline手続き
　　　　　　　行をコンパイルします。

            　行番号を行番号リストに登録し、<改行>がくるまでStatement
            手続きを呼出しつづけます。


　４．変更来歴

　     93.06.22 　IF文の判断を誤るバグを修正した。
　　　 93.06.25   同一アドレスのラベルを出力する方法を EQU * に変更した。
       93.06.28   コマンド名を TNKC より TNKB に変更。
       93.10.26   IF文の構文を IF <式> THEN <文> に変更した。
       93.10.28   USING文,RESTORE文の追加。
       93.11.01   INLINE文の追加。
       93.11.03   手続き Expression における PUSH の生成忘れを訂正した。
　　　 93.11.08   同 Expression における余計な PUSH の生成を抑止した。


　５．終わりに

　　　今の所、TnkBは実用性が充分とはいえません。いくつかのバ
　　グも発見されています。今後バージョンアップを重ね、より確かなコンパイラと
　　して提供してゆく所存です。

　　　開発中、ポケット通信では以下のかたにご指導頂き真に有難う御座いました。

　　　　M.Nakabayashi様
　　　　E.Kako様

　　　さらには、バイナリ転送プログラムＢＩＮＲＳの使用を快諾戴いたＲｅｖ氏に
　　感謝いたします。

  　　本ソフトは BORLAND INTERNATIONAL 社の Turbo Pascal V7.0 で開発しました。


付録１　参考文献

　　近成人　　「試作コンパイラの設計と実装」　ＰＪ　　　　　　　　工学社
　　疋田輝男　「コンパイラ」　　　　　　　　　　　　　　　　　　　昭晃堂
　　山口敏郎　「ＴＹコンパイラ」　　　　　　　ＰＩＯスペシャル３　工学社


付録２　エラーメッセージ一覧

        Syntax error.       コマンド名の綴りが間違っている。
        "(" expected.       括弧がない。
        ")" expected.       とじ括弧がない。
        "," expected.       カンマがない。
        NEXT is missing.    ＦＯＲ文に対応するＮＥＸＴ文がない。
        FOR  is missing.    ＮＥＸＴ文に対応するＦＯＲ文がない。
        GOSUB is missing.   ＲＥＴＵＲＮ文に対応するＧＯＳＵＢ文がない。
        RETURN is missing.  ＧＯＳＵＢ文に対応するＲＥＴＵＲＮ文がない。
        DIM is missing.     配列宣言がない。
        Bad expression.     式が間違っている。
        Undefined lineno.   飛び先の行番号がない。
        RESTORE is missing. ＲＥＳＴＯＲＥ文がない。
        Literal data over.  数値データが規定値を越えて使用されている。


付録３　TnkBのBNF図

　−データ−

<文字> ::= <英大文字>|<英小文字>|<その他の記号>
<数>       　  ::= 0|1|2|3|4|5|6|7|8|9
<英大文字> 　  ::= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
<英小文字>  　 ::=  a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
<その他の記号> ::= π|<ﾙｰﾄ> |*|/|+|-|!|"|#|$|%|&|'|(|)|^|\|@|,|.|[|]
<ﾙｰﾄ>          ::= SQRT
<十進数>   ::= <数>{<数>}
<ﾏｼﾝｺﾞﾃﾞｰﾀ>::= <M1><M1>{<M1><M1>}
<M1>       ::= <数>|A|B|C|D|E|F
<十進定数> ::= <十進数>
<文字定数> ::=　”<文字>”
<変数>     ::= <単純変数>|<配列変数>
<単純変数> ::= <英大文字>{$}

<配列変数> ::= <配列B>（式）
<配列B>    ::= A|A$|B|B$

　−式−

<加法演算子> ::= ＋|−|ＯＲ
<乗法演算子> ::= ＊|／|ＡＮＤ
<関係演算子> ::= ＝|＜＞|＜＝|＞＝|＝＞|＝＜
<式>       ::= <単純式><関係演算子><単純式>
<単純式>   ::= <項>{<加法演算子><項>}
<項>       ::= <因子>{<乗法演算子><因子>}
<因子>     ::= <定数>|<変数>|<関数>|（式）
<定数>     ::= <十進定数>|<文字定数>

　−関数−

<関数>   ::= <ASC関数>|<CHR$関数>|<INKEY$関数>|<POINT関数>|<RND関数>|<ﾙｰﾄ関数>
<ASC関数>    ::=ＡＳＣ<変数>
<CHR$関数>   ::=ＣＨＲ＄<式>
<INKEY$関数> ::=ＩＮＫＥＹ＄
<POINT関数>  ::=ＰＯＩＮＴ（<式>,<式>）
<RND関数>    ::=ＲＮＤ<式>
<ﾙｰﾄ関数>    ::=<ﾙｰﾄ><式>

　−文−

<文>     ::= <代入文>|<実行文>

<代入文>    ::= <変数>＝<式>

<実行文> ::= <BEEP文>|<CLEAR文>|<CLS文>|<CURSOR文>|<DATA文>|<END文>
            |<GCURSOR文>|<GOSUB文>|<GOTO文>|<GPRINT文>|<IF文>|<INPUT文>
            |<PRESET文>|<PRINT文>|<PSET文>|<READ文>|<RESTORE文>|<RETURN文>
            |<USING文>|<WAIT文>|<ｲﾝﾗｲﾝ文>

<BEEP文>    ::= ＢＥＥＰ|<BEEP2>
<BEEP2>     ::= ε|<文字定数>|ＯＦＦ
<CLEAR文>   ::= ＣＬＥＡＲ
<CLS文>     ::= ＣＬＳ
<CURSOR文>  ::= ＣＵＲＳＯＲ<式>，<式>
<DATA文>    ::= ＤＡＴＡ <定数>{，<定数>}
<END文>     ::= ＥＮＤ
<GCURSOR文> ::= ＧＣＵＲＣＯＲ（<式>，<式>）
<GOSUB文>   ::= ＧＯＳＵＢ<行番号>
<GOTO文>    ::= ＧＯＴＯ<行番号>
<GPRINT文>  ::= ＧＰＲＩＮＴ<GPRINT2>
<GPRINT2>   ::= ε|＃<式>|<式>
<IF文>      ::= ＩＦ<式><IF2>{：<文>}
<IF2>       ::= ＬＥＴ<代入文>|ＴＨＥＮ<実行文>
<INPUT文>   ::= ＩＮＰＵＴ<INPUT2>
<INPUT2>    ::= <変数>|<文字定数>；<変数>
<PRESET文>  ::= ＰＲＥＳＥＴ（<式>，<式>）
<PRINT文>   ::= ＰＲＩＮＴ（式）
<PSET文>    ::= ＰＳＥＴ（<式>，<式>）
<READ文>    ::= ＲＥＡＤ<変数>{，<変数>}
<RESTORE文> ::= ＲＥＳＴＯＲＥ<行番号>
<RETURN文>  ::= ＲＥＴＵＲＮ
<USING文>   ::= ＵＳＩＮＧ
<WAIT文>    ::= ＷＡＩＴ<WAIT2>
<WAIT2>     ::= ε|<式>
<ｲﾝﾗｲﾝ文>   ::= ！<ﾏｼﾝｺﾞﾃﾞｰﾀ>

　−プログラム−

<行番号>   ::= <行番号1><行番号2>
<行番号1>  ::= 1|2|3|4|5|6|7|8|9
<行番号2>  ::= <十進数>

<行>       ::= <行番号><文>{：<文>}<改行>

<TNKBﾌﾟﾛｸﾞﾗﾑ> ::= <行>{<行>}<EOF>



付録３　ＰＣ−１３５０への対応について。

　　ＲＵＮＴＩＭＥ．Ｈファイルに定義してあるエントリ番地を１３５０用に
　改造することにより１３５０用のマシン語ファイルを作成可能です。
